async function M(J,W){const X=await crypto.subtle.importKey("raw",typeof J==="string"?h.encode(J):J,{name:"HMAC",hash:{name:"SHA-256"}},!1,["sign"]);return crypto.subtle.sign("HMAC",X,h.encode(W))}async function c(J){return crypto.subtle.digest("SHA-256",typeof J==="string"?h.encode(J):J)}var R=function(J){return Array.prototype.map.call(new Uint8Array(J),(W)=>("0"+W.toString(16)).slice(-2)).join("")},i=function(J){return J.replace(/[!'()*]/g,(W)=>"%"+W.charCodeAt(0).toString(16).toUpperCase())},O0=function(J,W){const{hostname:X,pathname:$}=J;if(X.endsWith(".r2.cloudflarestorage.com"))return["s3","auto"];if(X.endsWith(".backblazeb2.com")){const D=X.match(/^(?:[^.]+\.)?s3\.([^.]+)\.backblazeb2\.com$/);return D!=null?["s3",D[1]]:["",""]}const Z=X.replace("dualstack.","").match(/([^.]+)\.(?:([^.]*)\.)?amazonaws\.com(?:\.cn)?$/);let[z,O]=(Z||["",""]).slice(1,3);if(O==="us-gov")O="us-gov-west-1";else if(O==="s3"||O==="s3-accelerate")O="us-east-1",z="s3";else if(z==="iot")if(X.startsWith("iot."))z="execute-api";else if(X.startsWith("data.jobs.iot."))z="iot-jobs-data";else z=$==="/mqtt"?"iotdevicegateway":"iotdata";else if(z==="autoscaling"){const D=(W.get("X-Amz-Target")||"").split(".")[0];if(D==="AnyScaleFrontendService")z="application-autoscaling";else if(D==="AnyScaleScalingPlannerFrontendService")z="autoscaling-plans"}else if(O==null&&z.startsWith("s3-"))O=z.slice(3).replace(/^fips-|^external-1/,""),z="s3";else if(z.endsWith("-fips"))z=z.slice(0,-5);else if(O&&/-\d$/.test(z)&&!/-\d$/.test(O))[z,O]=[O,z];return[z0[z]||z,O]},h=new TextEncoder,z0={appstream2:"appstream",cloudhsmv2:"cloudhsm",email:"ses",marketplace:"aws-marketplace",mobile:"AWSMobileHubService",pinpoint:"mobiletargeting",queue:"sqs","git-codecommit":"codecommit","mturk-requester-sandbox":"mturk-requester","personalize-runtime":"personalize"},Z0=new Set(["authorization","content-type","content-length","user-agent","presigned-expires","expect","x-amzn-trace-id","range","connection"]);class S{constructor({accessKeyId:J,secretAccessKey:W,sessionToken:X,service:$,region:Z,cache:z,retries:O,initRetryMs:D}){if(J==null)throw new TypeError("accessKeyId is a required option");if(W==null)throw new TypeError("secretAccessKey is a required option");this.accessKeyId=J,this.secretAccessKey=W,this.sessionToken=X,this.service=$,this.region=Z,this.cache=z||new Map,this.retries=O!=null?O:10,this.initRetryMs=D||50}async sign(J,W){if(J instanceof Request){const{method:Z,url:z,headers:O,body:D}=J;if(W=Object.assign({method:Z,url:z,headers:O},W),W.body==null&&O.has("Content-Type"))W.body=D!=null&&O.has("X-Amz-Content-Sha256")?D:await J.clone().arrayBuffer();J=z}const X=new n(Object.assign({url:J},W,this,W&&W.aws)),$=Object.assign({},W,await X.sign());delete $.aws;try{return new Request($.url.toString(),$)}catch(Z){if(Z instanceof TypeError)return new Request($.url.toString(),Object.assign({duplex:"half"},$));throw Z}}async fetch(J,W){for(let X=0;X<=this.retries;X++){const $=fetch(await this.sign(J,W));if(X===this.retries)return $;const Z=await $;if(Z.status<500&&Z.status!==429)return Z;await new Promise((z)=>setTimeout(z,Math.random()*this.initRetryMs*Math.pow(2,X)))}throw new Error("An unknown error occurred, ensure retries is not negative")}}class n{constructor({method:J,url:W,headers:X,body:$,accessKeyId:Z,secretAccessKey:z,sessionToken:O,service:D,region:Y,cache:P,datetime:F,signQuery:U,appendSessionToken:G,allHeaders:E,singleEncode:$0}){if(W==null)throw new TypeError("url is a required option");if(Z==null)throw new TypeError("accessKeyId is a required option");if(z==null)throw new TypeError("secretAccessKey is a required option");this.method=J||($?"POST":"GET"),this.url=new URL(W),this.headers=new Headers(X||{}),this.body=$,this.accessKeyId=Z,this.secretAccessKey=z,this.sessionToken=O;let f,y;if(!D||!Y)[f,y]=O0(this.url,this.headers);if(this.service=D||f||"",this.region=Y||y||"us-east-1",this.cache=P||new Map,this.datetime=F||(new Date()).toISOString().replace(/[:-]|\.\d{3}/g,""),this.signQuery=U,this.appendSessionToken=G||this.service==="iotdevicegateway",this.headers.delete("Host"),this.service==="s3"&&!this.signQuery&&!this.headers.has("X-Amz-Content-Sha256"))this.headers.set("X-Amz-Content-Sha256","UNSIGNED-PAYLOAD");const j=this.signQuery?this.url.searchParams:this.headers;if(j.set("X-Amz-Date",this.datetime),this.sessionToken&&!this.appendSessionToken)j.set("X-Amz-Security-Token",this.sessionToken);if(this.signableHeaders=["host",...this.headers.keys()].filter((Q)=>E||!Z0.has(Q)).sort(),this.signedHeaders=this.signableHeaders.join(";"),this.canonicalHeaders=this.signableHeaders.map((Q)=>Q+":"+(Q==="host"?this.url.host:(this.headers.get(Q)||"").replace(/\s+/g," "))).join("\n"),this.credentialString=[this.datetime.slice(0,8),this.region,this.service,"aws4_request"].join("/"),this.signQuery){if(this.service==="s3"&&!j.has("X-Amz-Expires"))j.set("X-Amz-Expires","86400");j.set("X-Amz-Algorithm","AWS4-HMAC-SHA256"),j.set("X-Amz-Credential",this.accessKeyId+"/"+this.credentialString),j.set("X-Amz-SignedHeaders",this.signedHeaders)}if(this.service==="s3")try{this.encodedPath=decodeURIComponent(this.url.pathname.replace(/\+/g," "))}catch(Q){this.encodedPath=this.url.pathname}else this.encodedPath=this.url.pathname.replace(/\/+/g,"/");if(!$0)this.encodedPath=encodeURIComponent(this.encodedPath).replace(/%2F/g,"/");this.encodedPath=i(this.encodedPath);const u=new Set;this.encodedSearch=[...this.url.searchParams].filter(([Q])=>{if(!Q)return!1;if(this.service==="s3"){if(u.has(Q))return!1;u.add(Q)}return!0}).map((Q)=>Q.map((I)=>i(encodeURIComponent(I)))).sort(([Q,I],[d,l])=>Q<d?-1:Q>d?1:I<l?-1:I>l?1:0).map((Q)=>Q.join("=")).join("&")}async sign(){if(this.signQuery){if(this.url.searchParams.set("X-Amz-Signature",await this.signature()),this.sessionToken&&this.appendSessionToken)this.url.searchParams.set("X-Amz-Security-Token",this.sessionToken)}else this.headers.set("Authorization",await this.authHeader());return{method:this.method,url:this.url,headers:this.headers,body:this.body}}async authHeader(){return["AWS4-HMAC-SHA256 Credential="+this.accessKeyId+"/"+this.credentialString,"SignedHeaders="+this.signedHeaders,"Signature="+await this.signature()].join(", ")}async signature(){const J=this.datetime.slice(0,8),W=[this.secretAccessKey,J,this.region,this.service].join();let X=this.cache.get(W);if(!X){const $=await M("AWS4"+this.secretAccessKey,J),Z=await M($,this.region),z=await M(Z,this.service);X=await M(z,"aws4_request"),this.cache.set(W,X)}return R(await M(X,await this.stringToSign()))}async stringToSign(){return["AWS4-HMAC-SHA256",this.datetime,this.credentialString,R(await c(await this.canonicalString()))].join("\n")}async canonicalString(){return[this.method.toUpperCase(),this.encodedPath,this.encodedSearch,this.canonicalHeaders+"\n",this.signedHeaders,await this.hexBodyHash()].join("\n")}async hexBodyHash(){let J=this.headers.get("X-Amz-Content-Sha256")||(this.service==="s3"&&this.signQuery?"UNSIGNED-PAYLOAD":null);if(J==null){if(this.body&&typeof this.body!=="string"&&!("byteLength"in this.body))throw new Error("body must be a string, ArrayBuffer or ArrayBufferView, unless you include the X-Amz-Content-Sha256 header");J=R(await c(this.body||""))}return J}}var a=(J,W)=>{const X=W.parseFromString(J,"text/xml"),$=X.getElementsByTagName("ListBucketResult")[0],Z=X.getElementsByTagName("Contents");if(!$||!Z)throw new Error(`Invalid XML: ${J}`);const z=(O,D)=>O.getElementsByTagName(D)[0]?.textContent;return{$metadata:{},IsTruncated:z($,"IsTruncated")==="true",Contents:Array.from(Z).map((O)=>({ChecksumAlgorithm:[z(O,"ChecksumAlgorithm")],ETag:z(O,"ETag"),Key:z(O,"Key"),LastModified:new Date(z(O,"LastModified")),Owner:{DisplayName:z(O,"DisplayName"),ID:z(O,"ID")},Size:parseInt(z(O,"Size")),StorageClass:z(O,"StorageClass")})),Name:z(X,"Name"),Prefix:z(X,"Prefix"),Delimiter:z(X,"Delimiter"),MaxKeys:parseInt(z(X,"MaxKeys")),CommonPrefixes:Array.from(X.getElementsByTagName("CommonPrefixes")[0]?.getElementsByTagName("Prefix")||[]).map((O)=>({Prefix:O.textContent})),EncodingType:z(X,"EncodingType"),KeyCount:parseInt(z(X,"KeyCount")),ContinuationToken:z(X,"ContinuationToken"),NextContinuationToken:z(X,"NextContinuationToken"),StartAfter:z(X,"StartAfter")}};var N=async(J,{retries:W=Number.MAX_VALUE,delay:X=100,max_delay:$=1e4}={})=>{try{return await J()}catch(Z){if(W>0)return await new Promise((z)=>setTimeout(z,X)),N(J,{retries:W-1,max_delay:$,delay:Math.min(X*1.5,$)});throw Z}};class b{J;W;X;constructor(J,W,X){this.fetch=J;this.endpoint=W;this.parser=X}getUrl(J,W,X){return`${this.endpoint}/${J}${W?`/${W}`:""}${X||""}`}async listObjectV2(J){for(let W=0;W<10;W++){const X=this.getUrl(J.Bucket,void 0,`/?list-type=2&prefix=${J.Prefix}`),$=await N(()=>this.fetch(X,{}));if($.status===200)return a(await $.text(),this.parser);else if($.status===429)console.warn("listObjectV2: 429, retrying"),await new Promise((Z)=>setTimeout(Z,1000));else throw new Error(`Unexpected response: ${$.status} ${await $.text()}`)}throw new Error("Cannot contact server")}async putObject({Bucket:J,Key:W,Body:X,ChecksumSHA256:$}){const Z=this.getUrl(J,W),z=await N(()=>this.fetch(Z,{method:"PUT",body:X,headers:{"Content-Type":"application/json",...$&&{"x-amz-content-sha256":$}}}));if(z.status!==200)throw new Error(`Failed to PUT: ${await z.text()}`);return{$metadata:{httpStatusCode:z.status},ETag:z.headers.get("ETag"),...z.headers.get("x-amz-version-id")&&{VersionId:z.headers.get("x-amz-version-id")}}}async deleteObject({Bucket:J,Key:W}){return{$metadata:{httpStatusCode:(await N(()=>this.fetch(this.getUrl(J,W),{method:"DELETE"}))).status}}}async getObject({Bucket:J,Key:W,VersionId:X,IfNoneMatch:$}){const Z=this.getUrl(J,W,X?`?versionId=${X}`:""),z=await N(()=>this.fetch(Z,{method:"GET",headers:{"If-None-Match":$}}));switch(z.status){case 304:throw new Error("304");case 404:return{$metadata:{httpStatusCode:404}};case 403:throw new Error("Access denied");default:{let O;const D=z.headers.get("content-type"),Y=await z.text();if(D==="application/json"||Y&&Y!=="")try{O=JSON.parse(Y)}catch(P){throw new Error(`Failed to parse response as JSON ${Z}`)}return{$metadata:{httpStatusCode:z.status},Body:O,ETag:z.headers.get("ETag"),...z.headers.get("x-amz-version-id")&&{VersionId:z.headers.get("x-amz-version-id")}}}}}}class V{key;_vals;_keys;constructor(J,W){if(this.key=J,this._vals=new Map,this._keys=new Map,W)for(let[X,$]of W)this.set(X,$)}get size(){return this._vals.size}set(J,W){const X=this.key(J);return this._vals.set(X,W),this._keys.set(X,J),this}get(J){return this._vals.get(this.key(J))}delete(J){const W=this.key(J);return this._keys.delete(W),this._vals.delete(W)}has(J){return this._vals.has(this.key(J))}values(){return this._vals.values()}keys(){return this._keys.values()}forEach(J){return this._vals.forEach((W,X,$)=>J(W,this._keys.get(X)))}}var o=()=>`${Date.now()-200}`.padStart(14,"0"),t=()=>`${Date.now()+200}`.padStart(14,"0");var _=()=>crypto.randomUUID();var C=(J)=>`${J.bucket}/${J.key}`;var T=(J)=>JSON.parse(JSON.stringify(J));var H=function(J){return new Promise((W,X)=>{J.oncomplete=J.onsuccess=()=>W(J.result),J.onabort=J.onerror=()=>X(J.error)})},x=function(J,W){const X=indexedDB.open(J);X.onupgradeneeded=()=>X.result.createObjectStore(W);const $=H(X);return(Z,z)=>$.then((O)=>z(O.transaction(W,Z).objectStore(W)))},A=function(){if(!v)v=x("keyval-store","keyval");return v},L=function(J,W=A()){return W("readonly",(X)=>H(X.get(J)))},B=function(J,W,X=A()){return X("readwrite",($)=>{return $.put(W,J),H($.transaction)})};var s=function(J,W=A()){return W("readonly",(X)=>Promise.all(J.map(($)=>H(X.get($)))))};var K=function(J,W=A()){return W("readwrite",(X)=>{return J.forEach(($)=>X.delete($)),H(X.transaction)})};var D0=function(J,W){return J.openCursor().onsuccess=function(){if(!this.result)return;W(this.result),this.result.continue()},H(J.transaction)},e=function(J=A()){return J("readonly",(W)=>{if(W.getAllKeys)return H(W.getAllKeys());const X=[];return D0(W,($)=>X.push($.key)).then(()=>X)})};var v;var Q0=6,J0=(J)=>`write-${J.toString().padStart(Q0,"0")}`;class g{session=_();proposedOperations=new Map;operationLabels=new Map;db;lastIndex=0;load=void 0;constructor(J){this.db=J}async propose(J,W,X=!1){if(this.proposedOperations.set(J,W),this.db){if(this.load&&!X)await this.load,this.proposedOperations.delete(J),this.proposedOperations.set(J,W);this.lastIndex++;const $=J0(this.lastIndex);J[this.session]=this.lastIndex,await B($,[...W.entries()].map(([Z,z])=>[JSON.stringify(Z),z]),this.db),console.log(`STORE ${$} ${JSON.stringify([...W.entries()])}`)}}async label(J,W,X=!1){if(this.operationLabels.set(W,J),this.db){if(this.load&&!X)await this.load;const $=J[this.session];if($===void 0)throw new Error("Cannot label an unproposed operation");const Z=`label-${$}`;await B(Z,W,this.db),console.log(`STORE ${Z} ${W}`)}}async confirm(J,W=!1){if(this.operationLabels.has(J)){const X=this.operationLabels.get(J);if(this.proposedOperations.delete(X),this.operationLabels.delete(J),this.db){if(this.load&&!W)await this.load;const $=X[this.session],Z=[J0($),`label-${$}`];await K(Z,this.db),console.log(`DEL ${Z}`)}}}async cancel(J,W=!1){if(this.operationLabels.forEach((X,$)=>{if(X===J)this.operationLabels.delete($)}),this.proposedOperations.delete(J),this.db){if(this.load&&!W)await this.load;const X=J[this.session];await K([`write-${X}`,`label-${X}`],this.db)}}async flatten(){if(this.load)await this.load;const J=new V(C);return this.proposedOperations.forEach((W)=>{W.forEach((X,$)=>{J.set($,X)})}),J}async restore(J,W){return this.db=J,this.proposedOperations.clear(),this.operationLabels.clear(),this.lastIndex=0,this.load=new Promise(async(X)=>{const Z=(await e(this.db)).filter((O)=>O.startsWith("write-")).sort();console.log("RESTORE",Z);const z=await s(Z,this.db);for(let O=0;O<Z.length;O++){const D=parseInt(Z[O].split("-")[1]);this.lastIndex=Math.max(this.lastIndex,D)}for(let O=0;O<Z.length;O++){const D=Z[O],Y=parseInt(D.split("-")[1]),P=z[O].map(([G,E])=>[JSON.parse(G),E]),F=await L(`label-${Y}`,this.db);if(!P)continue;const U=new Map(P);await W(U,F),await K([`write-${Y}`,`label-${Y}`],this.db)}X(void 0)}),this.load}}function w(J,W){if(Array.isArray(W)||typeof W!=="object"||W===null)return W;if(typeof J!=="object"||J===null)J={};for(let X in W)if(W[X]===null)delete J[X];else J[X]=w(J[X],W[X]);return J}var k="manifest",q={previous:".",files:{},update:{}};class m{J;authoritative_key="";authoritative_state=T(q);optimistic_state=T(q);loading;cache;db;constructor(J){this.manifest=J}async restore(J){this.db=J,this.loading=L(k,J).then((W)=>{if(W)this.authoritative_state=W,this.optimistic_state=W,console.log(`${this.manifest.service.config.label} RESTORE ${k}`)})}async getLatest(){if(this.loading)await this.loading;if(this.loading=void 0,!this.manifest.service.config.online)return this.authoritative_state;try{const J=await this.manifest.service._getObject({operation:"POLL_TIME",ref:this.manifest.ref,ifNoneMatch:this.cache?.etag,useCache:!1});if(J.$metadata.httpStatusCode===304)return this.authoritative_state;if(J.data===void 0)this.authoritative_key=".";else this.authoritative_key=J.data;const W=await this.manifest.service.s3ClientLite.listObjectV2({Bucket:this.manifest.ref.bucket,Prefix:this.manifest.ref.key,StartAfter:this.authoritative_key});if(W.Contents===void 0)return this.authoritative_state=T(q),this.optimistic_state=T(q),this.authoritative_state;const X=`${this.manifest.ref.key}@${o()}`;for(let $=W.Contents.length-1;$>=0;$--){const Z=W.Contents[$].Key;if(Z==this.manifest.ref.key)continue;const z={bucket:this.manifest.ref.bucket,key:Z},O=await this.manifest.service._getObject({operation:"LOOK_BACK",ref:z});if(O.data===void 0){await this.manifest.service._deleteObject({operation:"CLEANUP",ref:z});continue}if(O.data.previous<X){this.authoritative_key=O.data.previous,this.authoritative_state=O.data;break}}for(let $=0;$<W.Contents.length;$++){const Z=W.Contents[$].Key;if(Z==this.manifest.ref.key)continue;if(Z<this.authoritative_key)continue;const z=await this.manifest.service._getObject({operation:"SWEEP",ref:{bucket:this.manifest.ref.bucket,key:Z}}),O=Z.substring(Z.lastIndexOf("@")+1);if(O>=X)console.log("Optimistic update"),this.optimistic_state=w(this.optimistic_state,z.data?.update);else this.authoritative_state=w(this.authoritative_state,z.data?.update),this.optimistic_state=w(this.optimistic_state,z.data?.update),this.authoritative_key=Z;this.manifest.observeVersionId(O)}if(this.db)B(k,this.authoritative_state,this.db);return this.authoritative_state}catch(J){if(J.name==="NoSuchKey")return this.authoritative_state=q,this.authoritative_state;else throw J}}}class W0{J;W;X;queue=Promise.resolve();constructor(J,W,X){this.ref=J;this.handler=W;this.lastVersion=X}notify(J,W,X){this.queue=this.queue.then(()=>X).then(($)=>{if(W!==this.lastVersion)console.log(`${J} NOTIFY ${C(this.ref)} ${W}`),this.lastVersion=W,this.handler($)})}}class p{J;W;subscribers=new Set;poller;pollInProgress=!1;manifestState=new m(this);operationQueue=new g;constructor(J,W){this.service=J;this.ref=W;console.log("Create manifest",C(W))}load(J){this.manifestState.restore(J),this.operationQueue.restore(J,async(W,X)=>{if(!X)await this.service._putAll(W,{manifests:[this.ref],await:"local",isLoad:!0});else await this.updateContent(W,Promise.resolve(new Map([[this.ref,X]])),{await:"local",isLoad:!0})})}observeVersionId(J){this.operationQueue.confirm(J)}async poll(){if(this.pollInProgress)return;if(this.pollInProgress=!0,this.subscriberCount===0&&this.poller)clearInterval(this.poller),this.poller=void 0;if(this.subscriberCount>0&&!this.poller)this.poller=setInterval(()=>this.poll(),this.service.config.pollFrequency);const J=await this.manifestState.getLatest();if(J===void 0){this.pollInProgress=!1;return}const W=await this.operationQueue.flatten();this.subscribers.forEach(async(X)=>{if(W.has(X.ref))X.notify(this.service.config.label,"local",Promise.resolve(W.get(X.ref)));else{const $=J.files[C(X.ref)];if($){const Z=this.service._getObject({operation:"GET_CONTENT",ref:X.ref,version:$.version});X.notify(this.service.config.label,$.version,Z.then((z)=>z.data))}else if($===null)X.notify(this.service.config.label,void 0,Promise.resolve(void 0))}}),this.pollInProgress=!1}updateContent(J,W,X){const $=this.operationQueue.propose(W,J,X.isLoad),Z=$.then(async()=>{try{const z=await W,O=await this.manifestState.getLatest();O.previous=this.manifestState.authoritative_key,O.update={files:{}};for(let[F,U]of z){const G=C(F);if(U){const E={version:U};O.update.files[G]=E}else O.update.files[G]=null}const D=t()+"_"+_().substring(0,2),Y=this.ref.key+"@"+D;this.operationQueue.label(W,D,X.isLoad),await this.service._putObject({operation:"PUT_MANIFEST",ref:{key:Y,bucket:this.ref.bucket},value:O});const P=await this.service._putObject({operation:"PUT_POLL",ref:{key:this.ref.key,bucket:this.ref.bucket},value:this.manifestState.authoritative_key});return this.poll(),P}catch(z){throw console.error(z),this.operationQueue.cancel(W,X.isLoad),z}});if(X.await==="local")return $;else return Z}async getOptimisticVersion(J){return await this.manifestState.getLatest(),this.manifestState.optimistic_state.files[C(J)]?.version}subscribe(J,W){console.log(`SUBSCRIBE ${C(J)} ${this.subscriberCount+1}`);const X=new W0(J,W);return this.subscribers.add(X),()=>this.subscribers.delete(X)}get subscriberCount(){return this.subscribers.size}}async function X0(J){const W=(new TextEncoder()).encode(J),X=await crypto.subtle.digest("SHA-256",W);return[...new Uint8Array(X)].map(($)=>$.toString(16).padStart(2,"0")).join("")}class Y0{config;s3ClientLite;manifests=new V(C);memCache=new V((J)=>`${J.Bucket}${J.Key}${J.VersionId}${J.IfNoneMatch}`);diskCache;endpoint;constructor(J){if(this.config={...J,label:J.label||"default",useChecksum:J.useChecksum===!1?!1:!0,online:J.online===!1?!1:!0,offlineStorage:J.offlineStorage===!1?!1:!0,useVersioning:J.useVersioning||!1,pollFrequency:J.pollFrequency||1000,defaultManifest:{bucket:J.defaultManifest?.bucket||J.defaultBucket,key:typeof J.defaultManifest=="string"?J.defaultManifest:J.defaultManifest?.key||"manifest.json"}},this.config.s3Config?.credentials instanceof Function)throw Error("We can't do that yet");this.endpoint=J.s3Config.endpoint||`https://s3.${J.s3Config.region}.amazonaws.com`;let W;if(this.config.s3Config?.credentials){const X=new S({accessKeyId:this.config.s3Config.credentials.accessKeyId,secretAccessKey:this.config.s3Config.credentials.secretAccessKey,sessionToken:this.config.s3Config.credentials.sessionToken,region:this.config.s3Config.region||"us-east-1",service:"s3",retries:0});W=(...$)=>X.fetch(...$)}else W=(global||window).fetch.bind(global||window);if(this.config.offlineStorage){const X=`mps3-${this.config.label}`;this.diskCache=x(X,"v0")}this.s3ClientLite=new b(this.config.online?W:()=>new Promise(()=>{}),this.endpoint,J.parser||new DOMParser)}getOrCreateManifest(J){if(!this.manifests.has(J)){const W=new p(this,J);if(this.manifests.set(J,W),this.config.offlineStorage){const X=`mps3-${this.config.label}-${J.bucket}-${J.key}`,$=x(X,"v0");console.log(`${this.config.label} Restoring manifest from ${X}`),W.load($)}}return this.manifests.get(J)}async get(J,W={}){const X={...this.config.defaultManifest,...W.manifest},$=this.getOrCreateManifest(X),Z={bucket:J.bucket||this.config.defaultBucket||this.config.defaultManifest.bucket,key:typeof J==="string"?J:J.key},z=await $.operationQueue.flatten();if(z.has(Z))return console.log(`${this.config.label} GET (cached) ${Z} ${z.get(Z)}`),z.get(Z);const O=await $.getOptimisticVersion(Z);if(O===void 0)return;return(await this._getObject({operation:"GET",ref:Z,version:O})).data}async _getObject(J){let W;if(this.config.useVersioning)W={Bucket:J.ref.bucket,Key:J.ref.key,IfNoneMatch:J.ifNoneMatch,...J.version&&{VersionId:J.version}};else W={Bucket:J.ref.bucket,Key:`${J.ref.key}${J.version?`@${J.version}`:""}`,IfNoneMatch:J.ifNoneMatch};if(J.useCache!==!1){if(this.memCache.has(W))return this.memCache.get(W);const $=`${W.Bucket}${W.Key}${W.VersionId}`;if(this.diskCache){const Z=await L($,this.diskCache);if(Z)return console.log(`${this.config.label} ${J.operation} (disk cached) ${$}`),this.memCache.set(W,Promise.resolve(Z)),Z}}if(!this.config.online)throw new Error(`${this.config.label} Offline and value not cached for ${key}`);const X=this.s3ClientLite.getObject(W).then(async($)=>{const Z={$metadata:$.$metadata,ETag:$.ETag,data:$.Body};return console.log(`${this.config.label} ${J.operation} ${J.ref.bucket}/${J.ref.key}@${J.version} => ${Z.VersionId}`),Z}).catch(($)=>{if($?.name==="304")return{$metadata:{httpStatusCode:304},data:void 0};else throw $});if(J.useCache!==!1){if(this.memCache.set(W,X),this.diskCache)X.then(($)=>{B(`${W.Bucket}${W.Key}${W.VersionId}`,$,this.diskCache).then(()=>console.log(`${this.config.label} STORE ${W.Bucket}${W.Key}`))})}return X}async delete(J,W={}){return this.putAll(new Map([[J,void 0]]),W)}async put(J,W,X={}){if(!this.diskCache)throw new Error("No store");return this.putAll(new Map([[J,W]]),X)}async putAll(J,W={}){const X=new Map([...J].map(([Z,z])=>[{bucket:Z.bucket||this.config.defaultBucket||this.config.defaultManifest.bucket,key:typeof Z==="string"?Z:Z.key},z])),$=(W?.manifests||[this.config.defaultManifest]).map((Z)=>({...this.config.defaultManifest,...Z}));return this._putAll(X,{manifests:$,await:W.await||this.config.online?"remote":"local"})}async _putAll(J,W){const X=new Map,$=new Promise(async(Z,z)=>{const O=new Map,D=[];J.forEach((Y,P)=>{if(Y!==void 0){let F=this.config.useVersioning?void 0:_();X.set(P,Y),D.push(this._putObject({operation:"PUT_CONTENT",ref:P,value:Y,version:F}).then((U)=>{if(this.config.useVersioning)if(U.VersionId===void 0)throw console.error(U),Error(`Bucket ${P.bucket} is not version enabled!`);else F=U.VersionId;O.set(P,F)}))}else D.push(this._deleteObject({ref:P}).then((F)=>{O.set(P,void 0)}))}),await Promise.all(D).catch(z),Z(O)});return Promise.all(W.manifests.map((Z)=>{return this.getOrCreateManifest(Z).updateContent(X,$,{await:W.await,isLoad:W.isLoad===!0})}))}async _putObject(J){const W=JSON.stringify(J.value,null,2);let X;if(this.config.useVersioning)X={Bucket:J.ref.bucket,Key:J.ref.key,ContentType:"application/json",Body:W,...this.config.useChecksum&&{ChecksumSHA256:await X0(W)}};else X={Bucket:J.ref.bucket,Key:`${J.ref.key}${J.version?`@${J.version}`:""}`,ContentType:"application/json",Body:W,...this.config.useChecksum&&{ChecksumSHA256:await X0(W)}};const $=await this.s3ClientLite.putObject(X);if(console.log(`${this.config.label} ${J.operation} ${X.Bucket}/${X.Key} => ${$.VersionId}`),this.diskCache){const Z=`${X.Bucket}${X.Key}${J.version||$.VersionId}`;await B(Z,{$metadata:{httpStatusCode:200},etag:$.ETag,data:JSON.parse(W)},this.diskCache).then(()=>console.log(`${this.config.label} STORE ${Z}`))}return $}async _deleteObject(J){const W={Bucket:J.ref.bucket,Key:J.ref.key},X=await this.s3ClientLite.deleteObject(W);return console.log(`${this.config.label} ${J.operation||"DELETE"} ${J.ref.bucket}/${J.ref.key} => ${X.VersionId}`),X}subscribe(J,W,X){const $={...this.config.defaultManifest,...X?.manifest},Z={key:typeof J==="string"?J:J.key,bucket:J.bucket||this.config.defaultBucket||$.bucket},z=this.getOrCreateManifest($),O=z.subscribe(Z,W);return this.get(Z,{manifest:$}).then((D)=>{console.log(`${this.config.label} NOTIFY (initial) ${C(Z)}`),queueMicrotask(()=>{W(D,void 0),z.poll()})}).catch((D)=>{W(void 0,D)}),O}refresh(){return Promise.all([...this.manifests.values()].map((J)=>J.poll()))}get subscriberCount(){return[...this.manifests.values()].reduce((J,W)=>J+W.subscriberCount,0)}}export{Y0 as MPS3};
