async function M(z,J){const W=await crypto.subtle.importKey("raw",typeof z==="string"?h.encode(z):z,{name:"HMAC",hash:{name:"SHA-256"}},!1,["sign"]);return crypto.subtle.sign("HMAC",W,h.encode(J))}async function c(z){return crypto.subtle.digest("SHA-256",typeof z==="string"?h.encode(z):z)}var R=function(z){return Array.prototype.map.call(new Uint8Array(z),(J)=>("0"+J.toString(16)).slice(-2)).join("")},i=function(z){return z.replace(/[!'()*]/g,(J)=>"%"+J.charCodeAt(0).toString(16).toUpperCase())},Q0=function(z,J){const{hostname:W,pathname:X}=z;if(W.endsWith(".r2.cloudflarestorage.com"))return["s3","auto"];if(W.endsWith(".backblazeb2.com")){const Y=W.match(/^(?:[^.]+\.)?s3\.([^.]+)\.backblazeb2\.com$/);return Y!=null?["s3",Y[1]]:["",""]}const Z=W.replace("dualstack.","").match(/([^.]+)\.(?:([^.]*)\.)?amazonaws\.com(?:\.cn)?$/);let[$,Q]=(Z||["",""]).slice(1,3);if(Q==="us-gov")Q="us-gov-west-1";else if(Q==="s3"||Q==="s3-accelerate")Q="us-east-1",$="s3";else if($==="iot")if(W.startsWith("iot."))$="execute-api";else if(W.startsWith("data.jobs.iot."))$="iot-jobs-data";else $=X==="/mqtt"?"iotdevicegateway":"iotdata";else if($==="autoscaling"){const Y=(J.get("X-Amz-Target")||"").split(".")[0];if(Y==="AnyScaleFrontendService")$="application-autoscaling";else if(Y==="AnyScaleScalingPlannerFrontendService")$="autoscaling-plans"}else if(Q==null&&$.startsWith("s3-"))Q=$.slice(3).replace(/^fips-|^external-1/,""),$="s3";else if($.endsWith("-fips"))$=$.slice(0,-5);else if(Q&&/-\d$/.test($)&&!/-\d$/.test(Q))[$,Q]=[Q,$];return[$0[$]||$,Q]},h=new TextEncoder,$0={appstream2:"appstream",cloudhsmv2:"cloudhsm",email:"ses",marketplace:"aws-marketplace",mobile:"AWSMobileHubService",pinpoint:"mobiletargeting",queue:"sqs","git-codecommit":"codecommit","mturk-requester-sandbox":"mturk-requester","personalize-runtime":"personalize"},Z0=new Set(["authorization","content-type","content-length","user-agent","presigned-expires","expect","x-amzn-trace-id","range","connection"]);class S{constructor({accessKeyId:z,secretAccessKey:J,sessionToken:W,service:X,region:Z,cache:$,retries:Q,initRetryMs:Y}){if(z==null)throw new TypeError("accessKeyId is a required option");if(J==null)throw new TypeError("secretAccessKey is a required option");this.accessKeyId=z,this.secretAccessKey=J,this.sessionToken=W,this.service=X,this.region=Z,this.cache=$||new Map,this.retries=Q!=null?Q:10,this.initRetryMs=Y||50}async sign(z,J){if(z instanceof Request){const{method:Z,url:$,headers:Q,body:Y}=z;if(J=Object.assign({method:Z,url:$,headers:Q},J),J.body==null&&Q.has("Content-Type"))J.body=Y!=null&&Q.has("X-Amz-Content-Sha256")?Y:await z.clone().arrayBuffer();z=$}const W=new n(Object.assign({url:z},J,this,J&&J.aws)),X=Object.assign({},J,await W.sign());delete X.aws;try{return new Request(X.url.toString(),X)}catch(Z){if(Z instanceof TypeError)return new Request(X.url.toString(),Object.assign({duplex:"half"},X));throw Z}}async fetch(z,J){for(let W=0;W<=this.retries;W++){const X=fetch(await this.sign(z,J));if(W===this.retries)return X;const Z=await X;if(Z.status<500&&Z.status!==429)return Z;await new Promise(($)=>setTimeout($,Math.random()*this.initRetryMs*Math.pow(2,W)))}throw new Error("An unknown error occurred, ensure retries is not negative")}}class n{constructor({method:z,url:J,headers:W,body:X,accessKeyId:Z,secretAccessKey:$,sessionToken:Q,service:Y,region:P,cache:O,datetime:U,signQuery:j,appendSessionToken:V,allHeaders:L,singleEncode:X0}){if(J==null)throw new TypeError("url is a required option");if(Z==null)throw new TypeError("accessKeyId is a required option");if($==null)throw new TypeError("secretAccessKey is a required option");this.method=z||(X?"POST":"GET"),this.url=new URL(J),this.headers=new Headers(W||{}),this.body=X,this.accessKeyId=Z,this.secretAccessKey=$,this.sessionToken=Q;let f,y;if(!Y||!P)[f,y]=Q0(this.url,this.headers);if(this.service=Y||f||"",this.region=P||y||"us-east-1",this.cache=O||new Map,this.datetime=U||(new Date()).toISOString().replace(/[:-]|\.\d{3}/g,""),this.signQuery=j,this.appendSessionToken=V||this.service==="iotdevicegateway",this.headers.delete("Host"),this.service==="s3"&&!this.signQuery&&!this.headers.has("X-Amz-Content-Sha256"))this.headers.set("X-Amz-Content-Sha256","UNSIGNED-PAYLOAD");const C=this.signQuery?this.url.searchParams:this.headers;if(C.set("X-Amz-Date",this.datetime),this.sessionToken&&!this.appendSessionToken)C.set("X-Amz-Security-Token",this.sessionToken);if(this.signableHeaders=["host",...this.headers.keys()].filter((D)=>L||!Z0.has(D)).sort(),this.signedHeaders=this.signableHeaders.join(";"),this.canonicalHeaders=this.signableHeaders.map((D)=>D+":"+(D==="host"?this.url.host:(this.headers.get(D)||"").replace(/\s+/g," "))).join("\n"),this.credentialString=[this.datetime.slice(0,8),this.region,this.service,"aws4_request"].join("/"),this.signQuery){if(this.service==="s3"&&!C.has("X-Amz-Expires"))C.set("X-Amz-Expires","86400");C.set("X-Amz-Algorithm","AWS4-HMAC-SHA256"),C.set("X-Amz-Credential",this.accessKeyId+"/"+this.credentialString),C.set("X-Amz-SignedHeaders",this.signedHeaders)}if(this.service==="s3")try{this.encodedPath=decodeURIComponent(this.url.pathname.replace(/\+/g," "))}catch(D){this.encodedPath=this.url.pathname}else this.encodedPath=this.url.pathname.replace(/\/+/g,"/");if(!X0)this.encodedPath=encodeURIComponent(this.encodedPath).replace(/%2F/g,"/");this.encodedPath=i(this.encodedPath);const u=new Set;this.encodedSearch=[...this.url.searchParams].filter(([D])=>{if(!D)return!1;if(this.service==="s3"){if(u.has(D))return!1;u.add(D)}return!0}).map((D)=>D.map((x)=>i(encodeURIComponent(x)))).sort(([D,x],[d,l])=>D<d?-1:D>d?1:x<l?-1:x>l?1:0).map((D)=>D.join("=")).join("&")}async sign(){if(this.signQuery){if(this.url.searchParams.set("X-Amz-Signature",await this.signature()),this.sessionToken&&this.appendSessionToken)this.url.searchParams.set("X-Amz-Security-Token",this.sessionToken)}else this.headers.set("Authorization",await this.authHeader());return{method:this.method,url:this.url,headers:this.headers,body:this.body}}async authHeader(){return["AWS4-HMAC-SHA256 Credential="+this.accessKeyId+"/"+this.credentialString,"SignedHeaders="+this.signedHeaders,"Signature="+await this.signature()].join(", ")}async signature(){const z=this.datetime.slice(0,8),J=[this.secretAccessKey,z,this.region,this.service].join();let W=this.cache.get(J);if(!W){const X=await M("AWS4"+this.secretAccessKey,z),Z=await M(X,this.region),$=await M(Z,this.service);W=await M($,"aws4_request"),this.cache.set(J,W)}return R(await M(W,await this.stringToSign()))}async stringToSign(){return["AWS4-HMAC-SHA256",this.datetime,this.credentialString,R(await c(await this.canonicalString()))].join("\n")}async canonicalString(){return[this.method.toUpperCase(),this.encodedPath,this.encodedSearch,this.canonicalHeaders+"\n",this.signedHeaders,await this.hexBodyHash()].join("\n")}async hexBodyHash(){let z=this.headers.get("X-Amz-Content-Sha256")||(this.service==="s3"&&this.signQuery?"UNSIGNED-PAYLOAD":null);if(z==null){if(this.body&&typeof this.body!=="string"&&!("byteLength"in this.body))throw new Error("body must be a string, ArrayBuffer or ArrayBufferView, unless you include the X-Amz-Content-Sha256 header");z=R(await c(this.body||""))}return z}}var a=(z,J)=>{const W=J.parseFromString(z,"text/xml"),X=W.getElementsByTagName("ListBucketResult")[0],Z=W.getElementsByTagName("Contents");if(!X||!Z)throw new Error(`Invalid XML: ${z}`);const $=(Q,Y)=>Q.getElementsByTagName(Y)[0]?.textContent;return{$metadata:{},IsTruncated:$(X,"IsTruncated")==="true",Contents:Array.from(Z).map((Q)=>({ChecksumAlgorithm:[$(Q,"ChecksumAlgorithm")],ETag:$(Q,"ETag"),Key:$(Q,"Key"),LastModified:new Date($(Q,"LastModified")),Owner:{DisplayName:$(Q,"DisplayName"),ID:$(Q,"ID")},Size:parseInt($(Q,"Size")),StorageClass:$(Q,"StorageClass")})),Name:$(W,"Name"),Prefix:$(W,"Prefix"),Delimiter:$(W,"Delimiter"),MaxKeys:parseInt($(W,"MaxKeys")),CommonPrefixes:Array.from(W.getElementsByTagName("CommonPrefixes")[0]?.getElementsByTagName("Prefix")||[]).map((Q)=>({Prefix:Q.textContent})),EncodingType:$(W,"EncodingType"),KeyCount:parseInt($(W,"KeyCount")),ContinuationToken:$(W,"ContinuationToken"),NextContinuationToken:$(W,"NextContinuationToken"),StartAfter:$(W,"StartAfter")}};var N=async(z,{retries:J=Number.MAX_VALUE,delay:W=100}={})=>{try{return await z()}catch(X){if(J>0)return await new Promise((Z)=>setTimeout(Z,W)),N(z,{retries:J-1,delay:W});throw X}};class b{z;J;W;constructor(z,J,W){this.fetch=z;this.endpoint=J;this.parser=W}getUrl(z,J,W){return`${this.endpoint}/${z}${J?`/${J}`:""}${W||""}`}async listObjectV2(z){for(let J=0;J<10;J++){const W=this.getUrl(z.Bucket,void 0,`/?list-type=2&prefix=${z.Prefix}`),X=await N(()=>this.fetch(W,{}));if(X.status===200)return a(await X.text(),this.parser);else if(X.status===429)console.warn("listObjectV2: 429, retrying"),await new Promise((Z)=>setTimeout(Z,1000));else throw new Error(`Unexpected response: ${X.status} ${await X.text()}`)}throw new Error("Cannot contact server")}async putObject({Bucket:z,Key:J,Body:W,ChecksumSHA256:X}){const Z=this.getUrl(z,J),$=await N(()=>this.fetch(Z,{method:"PUT",body:W,headers:{"Content-Type":"application/json",...X&&{"x-amz-content-sha256":X}}}));if($.status!==200)throw new Error(`Failed to PUT: ${await $.text()}`);return{$metadata:{httpStatusCode:$.status},ETag:$.headers.get("ETag"),...$.headers.get("x-amz-version-id")&&{VersionId:$.headers.get("x-amz-version-id")}}}async deleteObject({Bucket:z,Key:J}){return{$metadata:{httpStatusCode:(await N(()=>this.fetch(this.getUrl(z,J),{method:"DELETE"}))).status}}}async getObject({Bucket:z,Key:J,VersionId:W,IfNoneMatch:X}){const Z=this.getUrl(z,J,W?`?versionId=${W}`:""),$=await N(()=>this.fetch(Z,{method:"GET",headers:{"If-None-Match":X}}));switch($.status){case 304:throw new Error("304");case 404:return{$metadata:{httpStatusCode:404}};case 403:throw new Error("Access denied");default:{let Q;const Y=$.headers.get("content-type"),P=await $.text();if(Y==="application/json"||P&&P!=="")try{Q=JSON.parse(P)}catch(O){throw new Error(`Failed to parse response as JSON ${Z}`)}return{$metadata:{httpStatusCode:$.status},Body:Q,ETag:$.headers.get("ETag"),...$.headers.get("x-amz-version-id")&&{VersionId:$.headers.get("x-amz-version-id")}}}}}}class _{key;_vals;_keys;constructor(z,J){if(this.key=z,this._vals=new Map,this._keys=new Map,J)for(let[W,X]of J)this.set(W,X)}get size(){return this._vals.size}set(z,J){const W=this.key(z);return this._vals.set(W,J),this._keys.set(W,z),this}get(z){return this._vals.get(this.key(z))}delete(z){const J=this.key(z);return this._keys.delete(J),this._vals.delete(J)}has(z){return this._vals.has(this.key(z))}values(){return this._vals.values()}keys(){return this._keys.values()}forEach(z){return this._vals.forEach((J,W,X)=>z(J,this._keys.get(W)))}}var o=()=>`${Date.now()-200}`.padStart(14,"0"),t=()=>`${Date.now()+200}`.padStart(14,"0");var E=()=>crypto.randomUUID();var F=(z)=>`${z.bucket}/${z.key}`;var T=(z)=>JSON.parse(JSON.stringify(z));var H=function(z){return new Promise((J,W)=>{z.oncomplete=z.onsuccess=()=>J(z.result),z.onabort=z.onerror=()=>W(z.error)})},I=function(z,J){const W=indexedDB.open(z);W.onupgradeneeded=()=>W.result.createObjectStore(J);const X=H(W);return(Z,$)=>X.then((Q)=>$(Q.transaction(J,Z).objectStore(J)))},A=function(){if(!v)v=I("keyval-store","keyval");return v},G=function(z,J=A()){return J("readonly",(W)=>H(W.get(z)))},B=function(z,J,W=A()){return W("readwrite",(X)=>{return X.put(J,z),H(X.transaction)})};var s=function(z,J=A()){return J("readonly",(W)=>Promise.all(z.map((X)=>H(W.get(X)))))};var K=function(z,J=A()){return J("readwrite",(W)=>{return z.forEach((X)=>W.delete(X)),H(W.transaction)})};var Y0=function(z,J){return z.openCursor().onsuccess=function(){if(!this.result)return;J(this.result),this.result.continue()},H(z.transaction)},e=function(z=A()){return z("readonly",(J)=>{if(J.getAllKeys)return H(J.getAllKeys());const W=[];return Y0(J,(X)=>W.push(X.key)).then(()=>W)})};var v;var D0=6,z0=(z)=>`write-${z.toString().padStart(D0,"0")}`;class g{session=E();proposedOperations=new Map;operationLabels=new Map;db;lastIndex=0;load=void 0;constructor(z){this.db=z}async propose(z,J,W=!1){if(this.proposedOperations.set(z,J),this.db){if(this.load&&!W)await this.load,this.proposedOperations.delete(z),this.proposedOperations.set(z,J);this.lastIndex++;const X=z0(this.lastIndex);z[this.session]=this.lastIndex,await B(X,[...J.entries()].map(([Z,$])=>[JSON.stringify(Z),$]),this.db),console.log(`STORE ${X} ${JSON.stringify([...J.entries()])}`)}}async label(z,J,W=!1){if(this.operationLabels.set(J,z),this.db){if(this.load&&!W)await this.load;const X=z[this.session];if(X===void 0)throw new Error("Cannot label an unproposed operation");const Z=`label-${X}`;await B(Z,J,this.db),console.log(`STORE ${Z} ${J}`)}}async confirm(z,J=!1){if(this.operationLabels.has(z)){const W=this.operationLabels.get(z);if(this.proposedOperations.delete(W),this.operationLabels.delete(z),this.db){if(this.load&&!J)await this.load;const X=W[this.session],Z=[z0(X),`label-${X}`];await K(Z,this.db),console.log(`DEL ${Z}`)}}}async cancel(z,J=!1){if(this.operationLabels.forEach((W,X)=>{if(W===z)this.operationLabels.delete(X)}),this.proposedOperations.delete(z),this.db){if(this.load&&!J)await this.load;const W=z[this.session];await K([`write-${W}`,`label-${W}`],this.db)}}async flatten(){if(this.load)await this.load;const z=new _(F);return this.proposedOperations.forEach((J)=>{J.forEach((W,X)=>{z.set(X,W)})}),z}async restore(z,J){return this.db=z,this.proposedOperations.clear(),this.operationLabels.clear(),this.lastIndex=0,this.load=new Promise(async(W)=>{const Z=(await e(this.db)).filter((Q)=>Q.startsWith("write-")).sort();console.log("RESTORE",Z);const $=await s(Z,this.db);for(let Q=0;Q<Z.length;Q++){const Y=parseInt(Z[Q].split("-")[1]);this.lastIndex=Math.max(this.lastIndex,Y)}for(let Q=0;Q<Z.length;Q++){const Y=Z[Q],P=parseInt(Y.split("-")[1]),O=$[Q].map(([V,L])=>[JSON.parse(V),L]),U=await G(`label-${P}`,this.db);if(!O)continue;const j=new Map(O);await J(j,U),await K([`write-${P}`,`label-${P}`],this.db)}W(void 0)}),this.load}}function w(z,J){if(Array.isArray(J)||typeof J!=="object"||J===null)return J;if(typeof z!=="object"||z===null)z={};for(let W in J)if(J[W]===null)delete z[W];else z[W]=w(z[W],J[W]);return z}var k="manifest",q={previous:".",files:{},update:{}};class p{z;authoritative_key="";authoritative_state=T(q);optimistic_state=T(q);loading;cache;db;constructor(z){this.manifest=z}async restore(z){this.db=z,this.loading=G(k,z).then((J)=>{if(J)this.authoritative_state=J,this.optimistic_state=J,console.log(`${this.manifest.service.config.label} RESTORE ${k}`)})}async getLatest(){if(this.loading)await this.loading;if(this.loading=void 0,!this.manifest.service.config.online)return this.authoritative_state;try{const z=await this.manifest.service._getObject({operation:"POLL_TIME",ref:this.manifest.ref,ifNoneMatch:this.cache?.etag});if(z.$metadata.httpStatusCode===304)return this.authoritative_state;if(z.data===void 0)this.authoritative_key=".";else this.authoritative_key=z.data;const J=await this.manifest.service.s3ClientLite.listObjectV2({Bucket:this.manifest.ref.bucket,Prefix:this.manifest.ref.key,StartAfter:this.authoritative_key});if(J.Contents===void 0)return this.authoritative_state=T(q),this.optimistic_state=T(q),this.authoritative_state;const W=`${this.manifest.ref.key}@${o()}`;for(let X=J.Contents.length-1;X>=0;X--){const Z=J.Contents[X].Key;if(Z==this.manifest.ref.key)continue;const $={bucket:this.manifest.ref.bucket,key:Z},Q=await this.manifest.service._getObject({operation:"LOOK_BACK",ref:$});if(Q.data===void 0){await this.manifest.service._deleteObject({operation:"CLEANUP",ref:$});continue}if(Q.data.previous<W){this.authoritative_key=Q.data.previous,this.authoritative_state=Q.data;break}}for(let X=0;X<J.Contents.length;X++){const Z=J.Contents[X].Key;if(Z==this.manifest.ref.key)continue;if(Z<this.authoritative_key)continue;const $=await this.manifest.service._getObject({operation:"SWEEP",ref:{bucket:this.manifest.ref.bucket,key:Z}}),Q=Z.substring(Z.lastIndexOf("@")+1);if(Q>=W)console.log("Optimistic update"),this.optimistic_state=w(this.optimistic_state,$.data?.update);else this.authoritative_state=w(this.authoritative_state,$.data?.update),this.optimistic_state=w(this.optimistic_state,$.data?.update),this.authoritative_key=Z;this.manifest.observeVersionId(Q)}if(this.db)B(k,this.authoritative_state,this.db);return this.authoritative_state}catch(z){if(z.name==="NoSuchKey")return this.authoritative_state=q,this.authoritative_state;else throw z}}}class J0{z;J;W;queue=Promise.resolve();constructor(z,J,W){this.ref=z;this.handler=J;this.lastVersion=W}notify(z,J,W){this.queue=this.queue.then(()=>W).then((X)=>{if(J!==this.lastVersion)console.log(`${z} NOTIFY ${F(this.ref)} ${J}`),this.lastVersion=J,this.handler(X)})}}class m{z;J;subscribers=new Set;poller;pollInProgress=!1;manifestState=new p(this);operationQueue=new g;constructor(z,J){this.service=z;this.ref=J;console.log("Create manifest",F(J))}load(z){this.manifestState.restore(z),this.operationQueue.restore(z,async(J,W)=>{if(!W)await this.service._putAll(J,{manifests:[this.ref],await:"local",isLoad:!0});else await this.updateContent(J,Promise.resolve(new Map([[this.ref,W]])),{await:"local",isLoad:!0})})}observeVersionId(z){this.operationQueue.confirm(z)}async poll(){if(this.pollInProgress)return;if(this.pollInProgress=!0,this.subscriberCount===0&&this.poller)clearInterval(this.poller),this.poller=void 0;if(this.subscriberCount>0&&!this.poller)this.poller=setInterval(()=>this.poll(),this.service.config.pollFrequency);const z=await this.manifestState.getLatest();if(z===void 0){this.pollInProgress=!1;return}const J=await this.operationQueue.flatten();this.subscribers.forEach(async(W)=>{if(J.has(W.ref))W.notify(this.service.config.label,"local",Promise.resolve(J.get(W.ref)));else{const X=z.files[F(W.ref)];if(X){const Z=this.service._getObject({operation:"GET_CONTENT",ref:W.ref,version:X.version});W.notify(this.service.config.label,X.version,Z.then(($)=>$.data))}else if(X===null)W.notify(this.service.config.label,void 0,Promise.resolve(void 0))}}),this.pollInProgress=!1}updateContent(z,J,W){const X=this.operationQueue.propose(J,z,W.isLoad),Z=X.then(async()=>{try{const $=await J,Q=await this.manifestState.getLatest();Q.previous=this.manifestState.authoritative_key,Q.update={files:{}};for(let[U,j]of $){const V=F(U);if(j){const L={version:j};Q.update.files[V]=L}else Q.update.files[V]=null}const Y=t()+"_"+E().substring(0,2),P=this.ref.key+"@"+Y;this.operationQueue.label(J,Y,W.isLoad),await this.service._putObject({operation:"PUT_MANIFEST",ref:{key:P,bucket:this.ref.bucket},value:Q});const O=await this.service._putObject({operation:"PUT_POLL",ref:{key:this.ref.key,bucket:this.ref.bucket},value:this.manifestState.authoritative_key});return this.poll(),O}catch($){throw console.error($),this.operationQueue.cancel(J,W.isLoad),$}});if(W.await==="local")return X;else return Z}async getOptimisticVersion(z){return await this.manifestState.getLatest(),this.manifestState.optimistic_state.files[F(z)]?.version}subscribe(z,J){console.log(`SUBSCRIBE ${F(z)} ${this.subscriberCount+1}`);const W=new J0(z,J);return this.subscribers.add(W),()=>this.subscribers.delete(W)}get subscriberCount(){return this.subscribers.size}}async function W0(z){const J=(new TextEncoder()).encode(z),W=await crypto.subtle.digest("SHA-256",J);return[...new Uint8Array(W)].map((X)=>X.toString(16).padStart(2,"0")).join("")}class P0{config;s3ClientLite;manifests=new _(F);memCache=new _((z)=>`${z.Bucket}${z.Key}${z.VersionId}${z.IfNoneMatch}`);diskCache;endpoint;constructor(z){if(this.config={...z,label:z.label||"default",useChecksum:z.useChecksum===!1?!1:!0,online:z.online===!1?!1:!0,offlineStorage:z.offlineStorage===!1?!1:!0,useVersioning:z.useVersioning||!1,pollFrequency:z.pollFrequency||1000,defaultManifest:{bucket:z.defaultManifest?.bucket||z.defaultBucket,key:typeof z.defaultManifest=="string"?z.defaultManifest:z.defaultManifest?.key||"manifest.json"}},this.config.s3Config?.credentials instanceof Function)throw Error("We can't do that yet");this.endpoint=z.s3Config.endpoint||`https://s3.${z.s3Config.region}.amazonaws.com`;let J;if(this.config.s3Config?.credentials){const W=new S({accessKeyId:this.config.s3Config.credentials.accessKeyId,secretAccessKey:this.config.s3Config.credentials.secretAccessKey,sessionToken:this.config.s3Config.credentials.sessionToken,region:this.config.s3Config.region||"us-east-1",service:"s3",retries:0});J=(...X)=>W.fetch(...X)}else J=(global||window).fetch.bind(global||window);if(this.config.offlineStorage){const W=`mps3-${this.config.label}`;this.diskCache=I(W,"v0")}this.s3ClientLite=new b(this.config.online?J:()=>new Promise(()=>{}),this.endpoint,z.parser||new DOMParser)}getOrCreateManifest(z){if(!this.manifests.has(z)){const J=new m(this,z);if(this.manifests.set(z,J),this.config.offlineStorage){const W=`mps3-${this.config.label}-${z.bucket}-${z.key}`,X=I(W,"v0");console.log(`${this.config.label} Restoring manifest from ${W}`),J.load(X)}}return this.manifests.get(z)}async get(z,J={}){const W={...this.config.defaultManifest,...J.manifest},X=this.getOrCreateManifest(W),Z={bucket:z.bucket||this.config.defaultBucket||this.config.defaultManifest.bucket,key:typeof z==="string"?z:z.key},$=await X.operationQueue.flatten();if($.has(Z))return console.log(`${this.config.label} GET (cached) ${Z} ${$.get(Z)}`),$.get(Z);const Q=await X.getOptimisticVersion(Z);if(Q===void 0)return;return(await this._getObject({operation:"GET",ref:Z,version:Q})).data}async _getObject(z){let J;if(this.config.useVersioning)J={Bucket:z.ref.bucket,Key:z.ref.key,IfNoneMatch:z.ifNoneMatch,...z.version&&{VersionId:z.version}};else J={Bucket:z.ref.bucket,Key:`${z.ref.key}${z.version?`@${z.version}`:""}`,IfNoneMatch:z.ifNoneMatch};if(this.memCache.has(J))return console.log(`${this.config.label} ${z.operation} (mem cached) ${J.Bucket}/${J.Key}`),this.memCache.get(J);const W=`${J.Bucket}${J.Key}${J.VersionId}`;if(this.diskCache){const Z=await G(W,this.diskCache);if(Z)return console.log(`${this.config.label} ${z.operation} (disk cached) ${W}`),this.memCache.set(J,Promise.resolve(Z)),Z}if(!this.config.online)throw new Error(`${this.config.label} Offline and value not cached for ${W}`);const X=this.s3ClientLite.getObject(J).then(async(Z)=>{const $={$metadata:Z.$metadata,ETag:Z.ETag,data:Z.Body};return console.log(`${this.config.label} ${z.operation} ${z.ref.bucket}/${z.ref.key}@${z.version} => ${$.VersionId}`),$}).catch((Z)=>{if(Z?.name==="304")return{$metadata:{httpStatusCode:304},data:void 0};else throw Z});if(this.memCache.set(J,X),this.diskCache)X.then((Z)=>{B(`${J.Bucket}${J.Key}${J.VersionId}`,Z,this.diskCache).then(()=>console.log(`${this.config.label} STORE ${J.Bucket}${J.Key}`))});return X}async delete(z,J={}){return this.putAll(new Map([[z,void 0]]),J)}async put(z,J,W={}){if(!this.diskCache)throw new Error("No store");return this.putAll(new Map([[z,J]]),W)}async putAll(z,J={}){const W=new Map([...z].map(([Z,$])=>[{bucket:Z.bucket||this.config.defaultBucket||this.config.defaultManifest.bucket,key:typeof Z==="string"?Z:Z.key},$])),X=(J?.manifests||[this.config.defaultManifest]).map((Z)=>({...this.config.defaultManifest,...Z}));return this._putAll(W,{manifests:X,await:J.await||this.config.online?"remote":"local"})}async _putAll(z,J){const W=new Map,X=new Promise(async(Z,$)=>{const Q=new Map,Y=[];z.forEach((P,O)=>{if(P!==void 0){let U=this.config.useVersioning?void 0:E();W.set(O,P),Y.push(this._putObject({operation:"PUT_CONTENT",ref:O,value:P,version:U}).then((j)=>{if(this.config.useVersioning)if(j.VersionId===void 0)throw console.error(j),Error(`Bucket ${O.bucket} is not version enabled!`);else U=j.VersionId;Q.set(O,U)}))}else Y.push(this._deleteObject({ref:O}).then((U)=>{Q.set(O,void 0)}))}),await Promise.all(Y).catch($),Z(Q)});return Promise.all(J.manifests.map((Z)=>{return this.getOrCreateManifest(Z).updateContent(W,X,{await:J.await,isLoad:J.isLoad===!0})}))}async _putObject(z){const J=JSON.stringify(z.value,null,2);let W;if(this.config.useVersioning)W={Bucket:z.ref.bucket,Key:z.ref.key,ContentType:"application/json",Body:J,...this.config.useChecksum&&{ChecksumSHA256:await W0(J)}};else W={Bucket:z.ref.bucket,Key:`${z.ref.key}${z.version?`@${z.version}`:""}`,ContentType:"application/json",Body:J,...this.config.useChecksum&&{ChecksumSHA256:await W0(J)}};const X=await this.s3ClientLite.putObject(W);if(console.log(`${this.config.label} ${z.operation} ${W.Bucket}/${W.Key} => ${X.VersionId}`),this.diskCache){const Z=`${W.Bucket}${W.Key}${z.version||X.VersionId}`;await B(Z,{$metadata:{httpStatusCode:200},etag:X.ETag,data:JSON.parse(J)},this.diskCache).then(()=>console.log(`${this.config.label} STORE ${Z}`))}return X}async _deleteObject(z){const J={Bucket:z.ref.bucket,Key:z.ref.key},W=await this.s3ClientLite.deleteObject(J);return console.log(`${this.config.label} ${z.operation||"DELETE"} ${z.ref.bucket}/${z.ref.key} => ${W.VersionId}`),W}subscribe(z,J,W){const X={...this.config.defaultManifest,...W?.manifest},Z={key:typeof z==="string"?z:z.key,bucket:z.bucket||this.config.defaultBucket||X.bucket},$=this.getOrCreateManifest(X),Q=$.subscribe(Z,J);return this.get(Z,{manifest:X}).then((Y)=>{console.log(`${this.config.label} NOTIFY (initial) ${F(Z)}`),queueMicrotask(()=>{J(Y,void 0),$.poll()})}).catch((Y)=>{J(void 0,Y)}),Q}refresh(){return Promise.all([...this.manifests.values()].map((z)=>z.poll()))}get subscriberCount(){return[...this.manifests.values()].reduce((z,J)=>z+J.subscriberCount,0)}}export{P0 as MPS3};
