async function V(J,$){const z=await crypto.subtle.importKey("raw",typeof J==="string"?K.encode(J):J,{name:"HMAC",hash:{name:"SHA-256"}},!1,["sign"]);return crypto.subtle.sign("HMAC",z,K.encode($))}async function u(J){return crypto.subtle.digest("SHA-256",typeof J==="string"?K.encode(J):J)}var I=function(J){return Array.prototype.map.call(new Uint8Array(J),($)=>("0"+$.toString(16)).slice(-2)).join("")},l=function(J){return J.replace(/[!'()*]/g,($)=>"%"+$.charCodeAt(0).toString(16).toUpperCase())},Y0=function(J,$){const{hostname:z,pathname:W}=J;if(z.endsWith(".r2.cloudflarestorage.com"))return["s3","auto"];if(z.endsWith(".backblazeb2.com")){const Q=z.match(/^(?:[^.]+\.)?s3\.([^.]+)\.backblazeb2\.com$/);return Q!=null?["s3",Q[1]]:["",""]}const Y=z.replace("dualstack.","").match(/([^.]+)\.(?:([^.]*)\.)?amazonaws\.com(?:\.cn)?$/);let[X,Z]=(Y||["",""]).slice(1,3);if(Z==="us-gov")Z="us-gov-west-1";else if(Z==="s3"||Z==="s3-accelerate")Z="us-east-1",X="s3";else if(X==="iot")if(z.startsWith("iot."))X="execute-api";else if(z.startsWith("data.jobs.iot."))X="iot-jobs-data";else X=W==="/mqtt"?"iotdevicegateway":"iotdata";else if(X==="autoscaling"){const Q=($.get("X-Amz-Target")||"").split(".")[0];if(Q==="AnyScaleFrontendService")X="application-autoscaling";else if(Q==="AnyScaleScalingPlannerFrontendService")X="autoscaling-plans"}else if(Z==null&&X.startsWith("s3-"))Z=X.slice(3).replace(/^fips-|^external-1/,""),X="s3";else if(X.endsWith("-fips"))X=X.slice(0,-5);else if(Z&&/-\d$/.test(X)&&!/-\d$/.test(Z))[X,Z]=[Z,X];return[W0[X]||X,Z]},K=new TextEncoder,W0={appstream2:"appstream",cloudhsmv2:"cloudhsm",email:"ses",marketplace:"aws-marketplace",mobile:"AWSMobileHubService",pinpoint:"mobiletargeting",queue:"sqs","git-codecommit":"codecommit","mturk-requester-sandbox":"mturk-requester","personalize-runtime":"personalize"},X0=new Set(["authorization","content-type","content-length","user-agent","presigned-expires","expect","x-amzn-trace-id","range","connection"]);class x{constructor({accessKeyId:J,secretAccessKey:$,sessionToken:z,service:W,region:Y,cache:X,retries:Z,initRetryMs:Q}){if(J==null)throw new TypeError("accessKeyId is a required option");if($==null)throw new TypeError("secretAccessKey is a required option");this.accessKeyId=J,this.secretAccessKey=$,this.sessionToken=z,this.service=W,this.region=Y,this.cache=X||new Map,this.retries=Z!=null?Z:10,this.initRetryMs=Q||50}async sign(J,$){if(J instanceof Request){const{method:Y,url:X,headers:Z,body:Q}=J;if($=Object.assign({method:Y,url:X,headers:Z},$),$.body==null&&Z.has("Content-Type"))$.body=Q!=null&&Z.has("X-Amz-Content-Sha256")?Q:await J.clone().arrayBuffer();J=X}const z=new c(Object.assign({url:J},$,this,$&&$.aws)),W=Object.assign({},$,await z.sign());delete W.aws;try{return new Request(W.url.toString(),W)}catch(Y){if(Y instanceof TypeError)return new Request(W.url.toString(),Object.assign({duplex:"half"},W));throw Y}}async fetch(J,$){for(let z=0;z<=this.retries;z++){const W=fetch(await this.sign(J,$));if(z===this.retries)return W;const Y=await W;if(Y.status<500&&Y.status!==429)return Y;await new Promise((X)=>setTimeout(X,Math.random()*this.initRetryMs*Math.pow(2,z)))}throw new Error("An unknown error occurred, ensure retries is not negative")}}class c{constructor({method:J,url:$,headers:z,body:W,accessKeyId:Y,secretAccessKey:X,sessionToken:Z,service:Q,region:F,cache:O,datetime:U,signQuery:B,appendSessionToken:_,allHeaders:L,singleEncode:z0}){if($==null)throw new TypeError("url is a required option");if(Y==null)throw new TypeError("accessKeyId is a required option");if(X==null)throw new TypeError("secretAccessKey is a required option");this.method=J||(W?"POST":"GET"),this.url=new URL($),this.headers=new Headers(z||{}),this.body=W,this.accessKeyId=Y,this.secretAccessKey=X,this.sessionToken=Z;let m,p;if(!Q||!F)[m,p]=Y0(this.url,this.headers);if(this.service=Q||m||"",this.region=F||p||"us-east-1",this.cache=O||new Map,this.datetime=U||(new Date()).toISOString().replace(/[:-]|\.\d{3}/g,""),this.signQuery=B,this.appendSessionToken=_||this.service==="iotdevicegateway",this.headers.delete("Host"),this.service==="s3"&&!this.signQuery&&!this.headers.has("X-Amz-Content-Sha256"))this.headers.set("X-Amz-Content-Sha256","UNSIGNED-PAYLOAD");const j=this.signQuery?this.url.searchParams:this.headers;if(j.set("X-Amz-Date",this.datetime),this.sessionToken&&!this.appendSessionToken)j.set("X-Amz-Security-Token",this.sessionToken);if(this.signableHeaders=["host",...this.headers.keys()].filter((D)=>L||!X0.has(D)).sort(),this.signedHeaders=this.signableHeaders.join(";"),this.canonicalHeaders=this.signableHeaders.map((D)=>D+":"+(D==="host"?this.url.host:(this.headers.get(D)||"").replace(/\s+/g," "))).join("\n"),this.credentialString=[this.datetime.slice(0,8),this.region,this.service,"aws4_request"].join("/"),this.signQuery){if(this.service==="s3"&&!j.has("X-Amz-Expires"))j.set("X-Amz-Expires","86400");j.set("X-Amz-Algorithm","AWS4-HMAC-SHA256"),j.set("X-Amz-Credential",this.accessKeyId+"/"+this.credentialString),j.set("X-Amz-SignedHeaders",this.signedHeaders)}if(this.service==="s3")try{this.encodedPath=decodeURIComponent(this.url.pathname.replace(/\+/g," "))}catch(D){this.encodedPath=this.url.pathname}else this.encodedPath=this.url.pathname.replace(/\/+/g,"/");if(!z0)this.encodedPath=encodeURIComponent(this.encodedPath).replace(/%2F/g,"/");this.encodedPath=l(this.encodedPath);const y=new Set;this.encodedSearch=[...this.url.searchParams].filter(([D])=>{if(!D)return!1;if(this.service==="s3"){if(y.has(D))return!1;y.add(D)}return!0}).map((D)=>D.map((w)=>l(encodeURIComponent(w)))).sort(([D,w],[d,f])=>D<d?-1:D>d?1:w<f?-1:w>f?1:0).map((D)=>D.join("=")).join("&")}async sign(){if(this.signQuery){if(this.url.searchParams.set("X-Amz-Signature",await this.signature()),this.sessionToken&&this.appendSessionToken)this.url.searchParams.set("X-Amz-Security-Token",this.sessionToken)}else this.headers.set("Authorization",await this.authHeader());return{method:this.method,url:this.url,headers:this.headers,body:this.body}}async authHeader(){return["AWS4-HMAC-SHA256 Credential="+this.accessKeyId+"/"+this.credentialString,"SignedHeaders="+this.signedHeaders,"Signature="+await this.signature()].join(", ")}async signature(){const J=this.datetime.slice(0,8),$=[this.secretAccessKey,J,this.region,this.service].join();let z=this.cache.get($);if(!z){const W=await V("AWS4"+this.secretAccessKey,J),Y=await V(W,this.region),X=await V(Y,this.service);z=await V(X,"aws4_request"),this.cache.set($,z)}return I(await V(z,await this.stringToSign()))}async stringToSign(){return["AWS4-HMAC-SHA256",this.datetime,this.credentialString,I(await u(await this.canonicalString()))].join("\n")}async canonicalString(){return[this.method.toUpperCase(),this.encodedPath,this.encodedSearch,this.canonicalHeaders+"\n",this.signedHeaders,await this.hexBodyHash()].join("\n")}async hexBodyHash(){let J=this.headers.get("X-Amz-Content-Sha256")||(this.service==="s3"&&this.signQuery?"UNSIGNED-PAYLOAD":null);if(J==null){if(this.body&&typeof this.body!=="string"&&!("byteLength"in this.body))throw new Error("body must be a string, ArrayBuffer or ArrayBufferView, unless you include the X-Amz-Content-Sha256 header");J=I(await u(this.body||""))}return J}}var i=(J,$)=>{const z=$.parseFromString(J,"text/xml"),W=z.getElementsByTagName("ListBucketResult")[0],Y=z.getElementsByTagName("Contents");if(!W||!Y)throw new Error(`Invalid XML: ${J}`);const X=(Z,Q)=>Z.getElementsByTagName(Q)[0]?.textContent;return{$metadata:{},IsTruncated:X(W,"IsTruncated")==="true",Contents:Array.from(Y).map((Z)=>({ChecksumAlgorithm:[X(Z,"ChecksumAlgorithm")],ETag:X(Z,"ETag"),Key:X(Z,"Key"),LastModified:new Date(X(Z,"LastModified")),Owner:{DisplayName:X(Z,"DisplayName"),ID:X(Z,"ID")},Size:parseInt(X(Z,"Size")),StorageClass:X(Z,"StorageClass")})),Name:X(z,"Name"),Prefix:X(z,"Prefix"),Delimiter:X(z,"Delimiter"),MaxKeys:parseInt(X(z,"MaxKeys")),CommonPrefixes:Array.from(z.getElementsByTagName("CommonPrefixes")[0]?.getElementsByTagName("Prefix")||[]).map((Z)=>({Prefix:Z.textContent})),EncodingType:X(z,"EncodingType"),KeyCount:parseInt(X(z,"KeyCount")),ContinuationToken:X(z,"ContinuationToken"),NextContinuationToken:X(z,"NextContinuationToken"),StartAfter:X(z,"StartAfter")}};var G=async(J,{retries:$=Number.MAX_VALUE,delay:z=100}={})=>{try{return await J()}catch(W){if($>0)return await new Promise((Y)=>setTimeout(Y,z)),G(J,{retries:$-1,delay:z});throw W}};class R{J;$;z;constructor(J,$,z){this.fetch=J;this.endpoint=$;this.parser=z}getUrl(J,$,z){return`${this.endpoint}/${J}${$?`/${$}`:""}${z||""}`}async listObjectV2(J){for(let $=0;$<10;$++){const z=this.getUrl(J.Bucket,void 0,`/?list-type=2&prefix=${J.Prefix}`),W=await G(()=>this.fetch(z,{}));if(W.status===200)return i(await W.text(),this.parser);else if(W.status===429)console.warn("listObjectV2: 429, retrying"),await new Promise((Y)=>setTimeout(Y,1000));else throw new Error(`Unexpected response: ${W.status} ${await W.text()}`)}throw new Error("Cannot contact server")}async putObject({Bucket:J,Key:$,Body:z,ChecksumSHA256:W}){const Y=this.getUrl(J,$),X=await G(()=>this.fetch(Y,{method:"PUT",body:z,headers:{"Content-Type":"application/json",...W&&{"x-amz-content-sha256":W}}}));if(X.status!==200)throw new Error(`Failed to PUT: ${await X.text()}`);return{$metadata:{httpStatusCode:X.status},ETag:X.headers.get("ETag"),...X.headers.get("x-amz-version-id")&&{VersionId:X.headers.get("x-amz-version-id")}}}async deleteObject({Bucket:J,Key:$}){return{$metadata:{httpStatusCode:(await G(()=>this.fetch(this.getUrl(J,$),{method:"DELETE"}))).status}}}async getObject({Bucket:J,Key:$,VersionId:z,IfNoneMatch:W}){const Y=this.getUrl(J,$,z?`?versionId=${z}`:""),X=await G(()=>this.fetch(Y,{method:"GET",headers:{"If-None-Match":W}}));switch(X.status){case 304:throw new Error("304");case 404:return{$metadata:{httpStatusCode:404}};case 403:throw new Error("Access denied");default:{let Z;const Q=X.headers.get("content-type"),F=await X.text();if(Q==="application/json"||F&&F!=="")try{Z=JSON.parse(F)}catch(O){throw new Error(`Failed to parse response as JSON ${Y}`)}return{$metadata:{httpStatusCode:X.status},Body:Z,ETag:X.headers.get("ETag"),...X.headers.get("x-amz-version-id")&&{VersionId:X.headers.get("x-amz-version-id")}}}}}}class H{key;_vals;_keys;constructor(J,$){if(this.key=J,this._vals=new Map,this._keys=new Map,$)for(let[z,W]of $)this.set(z,W)}get size(){return this._vals.size}set(J,$){const z=this.key(J);return this._vals.set(z,$),this._keys.set(z,J),this}get(J){return this._vals.get(this.key(J))}delete(J){const $=this.key(J);return this._keys.delete($),this._vals.delete($)}has(J){return this._vals.has(this.key(J))}values(){return this._vals.values()}keys(){return this._keys.values()}forEach(J){return this._vals.forEach(($,z,W)=>J($,this._keys.get(z)))}}var a=()=>`${Date.now()-200}`.padStart(14,"0"),n=()=>`${Date.now()+200}`.padStart(14,"0");var C=()=>crypto.randomUUID();var P=(J)=>`${J.bucket}/${J.key}`;var M=(J)=>JSON.parse(JSON.stringify(J));var E=function(J){return new Promise(($,z)=>{J.oncomplete=J.onsuccess=()=>$(J.result),J.onabort=J.onerror=()=>z(J.error)})},S=function(J,$){const z=indexedDB.open(J);z.onupgradeneeded=()=>z.result.createObjectStore($);const W=E(z);return(Y,X)=>W.then((Z)=>X(Z.transaction($,Y).objectStore($)))},T=function(){if(!h)h=S("keyval-store","keyval");return h},t=function(J,$=T()){return $("readonly",(z)=>E(z.get(J)))},b=function(J,$,z=T()){return z("readwrite",(W)=>{return W.put($,J),E(W.transaction)})};var r=function(J,$=T()){return $("readonly",(z)=>Promise.all(J.map((W)=>E(z.get(W)))))};var q=function(J,$=T()){return $("readwrite",(z)=>{return J.forEach((W)=>z.delete(W)),E(z.transaction)})};var Z0=function(J,$){return J.openCursor().onsuccess=function(){if(!this.result)return;$(this.result),this.result.continue()},E(J.transaction)},s=function(J=T()){return J("readonly",($)=>{if($.getAllKeys)return E($.getAllKeys());const z=[];return Z0($,(W)=>z.push(W.key)).then(()=>z)})};var h;var Q0=6,e=(J)=>`write-${J.toString().padStart(Q0,"0")}`;class v{session=C();proposedOperations=new Map;operationLabels=new Map;db;lastIndex=0;load=void 0;constructor(J){this.db=J}async propose(J,$,z=!1){if(this.proposedOperations.set(J,$),this.db){if(this.load&&!z)await this.load,this.proposedOperations.delete(J),this.proposedOperations.set(J,$);this.lastIndex++;const W=e(this.lastIndex);J[this.session]=this.lastIndex,await b(W,[...$.entries()].map(([Y,X])=>[JSON.stringify(Y),X]),this.db),console.log(`STORE ${W} ${JSON.stringify([...$.entries()])}`)}}async label(J,$,z=!1){if(this.operationLabels.set($,J),this.db){if(this.load&&!z)await this.load;const W=J[this.session];if(W===void 0)throw new Error("Cannot label an unproposed operation");const Y=`label-${W}`;await b(Y,$,this.db),console.log(`STORE ${Y}`)}}async confirm(J,$=!1){if(this.operationLabels.has(J)){const z=this.operationLabels.get(J);if(this.proposedOperations.delete(z),this.operationLabels.delete(J),this.db){if(this.load&&!$)await this.load;const W=z[this.session],Y=[e(W),`label-${W}`];await q(Y,this.db),console.log(`DEL ${Y}`)}}}async cancel(J,$=!1){if(this.operationLabels.forEach((z,W)=>{if(z===J)this.operationLabels.delete(W)}),this.proposedOperations.delete(J),this.db){if(this.load&&!$)await this.load;const z=J[this.session];await q([`write-${z}`,`label-${z}`],this.db)}}async flatten(){if(this.load)await this.load;const J=new H(P);return this.proposedOperations.forEach(($)=>{$.forEach((z,W)=>{J.set(W,z)})}),J}async restore(J,$){return this.db=J,this.proposedOperations.clear(),this.operationLabels.clear(),this.lastIndex=0,this.load=new Promise(async(z)=>{const Y=(await s(this.db)).filter((Z)=>Z.startsWith("write-")).sort();console.log("RESTORE",Y);const X=await r(Y,this.db);for(let Z=0;Z<Y.length;Z++){const Q=parseInt(Y[Z].split("-")[1]);this.lastIndex=Math.max(this.lastIndex,Q)}for(let Z=0;Z<Y.length;Z++){const Q=Y[Z],F=parseInt(Q.split("-")[1]),O=X[Z].map(([_,L])=>[JSON.parse(_),L]),U=await t(`label-${F}`,this.db);if(!O)continue;const B=new Map(O);await $(B,U),await q([`write-${F}`,`label-${F}`],this.db)}z(void 0)}),this.load}}function N(J,$){if(Array.isArray($)||typeof $!=="object"||$===null)return $;if(typeof J!=="object"||J===null)J={};for(let z in $)if($[z]===null)delete J[z];else J[z]=N(J[z],$[z]);return J}var A={previous:".",files:{},update:{}};class g{J;authoritative_key="";authoritative_state=M(A);optimistic_state=M(A);constructor(J){this.manifest=J}async getLatest(){try{const J=await this.manifest.service._getObject({operation:"POLL_TIME",ref:this.manifest.ref,ifNoneMatch:this.cache?.etag});if(J.$metadata.httpStatusCode===304)return;if(J.data===void 0)this.authoritative_key=".";else this.authoritative_key=J.data;const $=await this.manifest.service.s3ClientLite.listObjectV2({Bucket:this.manifest.ref.bucket,Prefix:this.manifest.ref.key,StartAfter:this.authoritative_key});if($.Contents===void 0)return this.authoritative_state=M(A),this.optimistic_state=M(A),this.authoritative_state;const z=`${this.manifest.ref.key}@${a()}`;for(let W=$.Contents.length-1;W>=0;W--){const Y=$.Contents[W].Key;if(Y==this.manifest.ref.key)continue;const X={bucket:this.manifest.ref.bucket,key:Y},Z=await this.manifest.service._getObject({operation:"LOOK_BACK",ref:X});if(Z.data===void 0){await this.manifest.service._deleteObject({operation:"CLEANUP",ref:X});continue}if(Z.data.previous<z){this.authoritative_key=Z.data.previous,this.authoritative_state=Z.data;break}}for(let W=0;W<$.Contents.length;W++){const Y=$.Contents[W].Key;if(Y==this.manifest.ref.key)continue;if(Y<this.authoritative_key)continue;const X=await this.manifest.service._getObject({operation:"SWEEP",ref:{bucket:this.manifest.ref.bucket,key:Y}}),Z=Y.substring(Y.lastIndexOf("@")+1);if(Z>=z)console.log("Optimistic update"),this.optimistic_state=N(this.optimistic_state,X.data?.update);else this.authoritative_state=N(this.authoritative_state,X.data?.update),this.optimistic_state=N(this.optimistic_state,X.data?.update),this.authoritative_key=Y;this.manifest.observeVersionId(Z)}return this.authoritative_state}catch(J){if(J.name==="NoSuchKey")return this.authoritative_state=A,this.authoritative_state;else throw J}}}class J0{J;$;z;queue=Promise.resolve();constructor(J,$,z){this.ref=J;this.handler=$;this.lastVersion=z}notify(J,$,z){this.queue=this.queue.then(()=>z).then((W)=>{if($!==this.lastVersion)console.log(`${J} NOTIFY ${P(this.ref)} ${$}`),this.lastVersion=$,this.handler(W)})}}class k{J;$;subscribers=new Set;poller;pollInProgress=!1;manifestState=new g(this);operationQueue=new v;constructor(J,$){this.service=J;this.ref=$;console.log("Create manifest",P($))}load(J){this.operationQueue.restore(J,async($,z)=>{if(!z)await this.service._putAll($,{manifests:[this.ref],await:"local",isLoad:!0});else await this.updateContent($,Promise.resolve(new Map([[this.ref,z]])),{await:"local",isLoad:!0})})}observeVersionId(J){this.operationQueue.confirm(J)}async poll(){if(this.pollInProgress)return;if(this.pollInProgress=!0,this.subscriberCount===0&&this.poller)clearInterval(this.poller),this.poller=void 0;if(this.subscriberCount>0&&!this.poller)this.poller=setInterval(()=>this.poll(),this.service.config.pollFrequency);const J=await this.manifestState.getLatest();if(J===void 0){this.pollInProgress=!1;return}const $=await this.operationQueue.flatten();this.subscribers.forEach(async(z)=>{if($.has(z.ref))z.notify(this.service.config.label,"local",Promise.resolve($.get(z.ref)));else{const W=J.files[P(z.ref)];if(W){const Y=this.service._getObject({operation:"GET_CONTENT",ref:z.ref,version:W.version});z.notify(this.service.config.label,W.version,Y.then((X)=>X.data))}else if(W===null)z.notify(this.service.config.label,void 0,Promise.resolve(void 0))}}),this.pollInProgress=!1}updateContent(J,$,z){const W=this.operationQueue.propose($,J,z.isLoad),Y=W.then(async()=>{try{const X=await $,Z=await this.manifestState.getLatest();Z.previous=this.manifestState.authoritative_key,Z.update={files:{}};for(let[U,B]of X){const _=P(U);if(B){const L={version:B};Z.update.files[_]=L}else Z.update.files[_]=null}const Q=n()+"_"+C().substring(0,2),F=this.ref.key+"@"+Q;this.operationQueue.label($,Q,z.isLoad),await this.service._putObject({operation:"PUT_MANIFEST",ref:{key:F,bucket:this.ref.bucket},value:Z});const O=await this.service._putObject({operation:"PUT_POLL",ref:{key:this.ref.key,bucket:this.ref.bucket},value:this.manifestState.authoritative_key});return this.poll(),O}catch(X){throw console.error(X),this.operationQueue.cancel($,z.isLoad),X}});if(z.await==="local")return W;else return Y}async getOptimisticVersion(J){return await this.manifestState.getLatest(),this.manifestState.optimistic_state.files[P(J)]?.version}subscribe(J,$){console.log(`SUBSCRIBE ${P(J)} ${this.subscriberCount+1}`);const z=new J0(J,$);return this.subscribers.add(z),()=>this.subscribers.delete(z)}get subscriberCount(){return this.subscribers.size}}async function $0(J){const $=(new TextEncoder()).encode(J),z=await crypto.subtle.digest("SHA-256",$);return[...new Uint8Array(z)].map((W)=>W.toString(16).padStart(2,"0")).join("")}class D0{config;s3ClientLite;manifests=new H(P);getCache=new H((J)=>`${J.Bucket}${J.Key}${J.VersionId}${J.IfNoneMatch}`);endpoint;constructor(J){if(this.config={...J,label:J.label||"default",useChecksum:J.useChecksum===!1?!1:!0,online:J.online===!1?!1:!0,offlineStorage:J.offlineStorage===!1?!1:!0,useVersioning:J.useVersioning||!1,pollFrequency:J.pollFrequency||1000,defaultManifest:{bucket:J.defaultManifest?.bucket||J.defaultBucket,key:typeof J.defaultManifest=="string"?J.defaultManifest:J.defaultManifest?.key||"manifest.json"}},this.config.s3Config?.credentials instanceof Function)throw Error("We can't do that yet");this.endpoint=J.s3Config.endpoint||`https://s3.${J.s3Config.region}.amazonaws.com`;let $;if(this.config.s3Config?.credentials){const z=new x({accessKeyId:this.config.s3Config.credentials.accessKeyId,secretAccessKey:this.config.s3Config.credentials.secretAccessKey,sessionToken:this.config.s3Config.credentials.sessionToken,region:this.config.s3Config.region||"us-east-1",service:"s3",retries:0});$=(...W)=>z.fetch(...W)}else $=(global||window).fetch.bind(global||window);this.s3ClientLite=new R(this.config.online?$:()=>new Promise(()=>{}),this.endpoint,J.parser||new DOMParser)}getOrCreateManifest(J){if(!this.manifests.has(J)){const $=new k(this,J);if(this.manifests.set(J,$),this.config.offlineStorage){const z=`mps3-${this.config.label}-${J.bucket}-${J.key}`,W=S(z,"v0");console.log(`${this.config.label} Restoring manifest from ${z}`),$.load(W)}}return this.manifests.get(J)}async get(J,$={}){const z={...this.config.defaultManifest,...$.manifest},W=this.getOrCreateManifest(z),Y={bucket:J.bucket||this.config.defaultBucket||this.config.defaultManifest.bucket,key:typeof J==="string"?J:J.key},X=await W.operationQueue.flatten();if(X.has(Y))return console.log(`${this.config.label} GET (cached) ${Y} ${X.get(Y)}`),X.get(Y);if(!this.config.online)throw new Error(`${this.config.label} Offline and value not cached for ${Y}`);const Z=await W.getOptimisticVersion(Y);if(Z===void 0)return;return(await this._getObject({operation:"GET",ref:Y,version:Z})).data}async _getObject(J){let $;if(this.config.useVersioning)$={Bucket:J.ref.bucket,Key:J.ref.key,IfNoneMatch:J.ifNoneMatch,...J.version&&{VersionId:J.version}};else $={Bucket:J.ref.bucket,Key:`${J.ref.key}${J.version?`@${J.version}`:""}`,IfNoneMatch:J.ifNoneMatch};if(this.getCache.has($))return await this.getCache.get($);const z=this.s3ClientLite.getObject($).then(async(W)=>{const Y={...W,data:W.Body};return console.log(`${this.config.label} ${J.operation} ${J.ref.bucket}/${J.ref.key}@${J.version} => ${Y.VersionId}`),this.getCache.set($,z),Y}).catch((W)=>{if(W?.name==="304")return{$metadata:{httpStatusCode:304},data:void 0};else throw W});return z}async delete(J,$={}){return this.putAll(new Map([[J,void 0]]),$)}async put(J,$,z={}){return this.putAll(new Map([[J,$]]),z)}async putAll(J,$={}){const z=new Map([...J].map(([Y,X])=>[{bucket:Y.bucket||this.config.defaultBucket||this.config.defaultManifest.bucket,key:typeof Y==="string"?Y:Y.key},X])),W=($?.manifests||[this.config.defaultManifest]).map((Y)=>({...this.config.defaultManifest,...Y}));return this._putAll(z,{manifests:W,await:$.await||this.config.online?"remote":"local"})}async _putAll(J,$){const z=new Map,W=new Promise(async(Y,X)=>{const Z=new Map,Q=[];J.forEach((F,O)=>{if(F!==void 0){let U=this.config.useVersioning?void 0:C();z.set(O,F),Q.push(this._putObject({operation:"PUT_CONTENT",ref:O,value:F,version:U}).then((B)=>{if(this.config.useVersioning)if(B.VersionId===void 0)throw console.error(B),Error(`Bucket ${O.bucket} is not version enabled!`);else U=B.VersionId;Z.set(O,U)}))}else Q.push(this._deleteObject({ref:O}).then((U)=>{Z.set(O,void 0)}))}),await Promise.all(Q).catch(X),Y(Z)});return Promise.all($.manifests.map((Y)=>{return this.getOrCreateManifest(Y).updateContent(z,W,{await:$.await,isLoad:$.isLoad===!0})}))}async _putObject(J){const $=JSON.stringify(J.value,null,2);let z;if(this.config.useVersioning)z={Bucket:J.ref.bucket,Key:J.ref.key,ContentType:"application/json",Body:$,...this.config.useChecksum&&{ChecksumSHA256:await $0($)}};else z={Bucket:J.ref.bucket,Key:`${J.ref.key}${J.version?`@${J.version}`:""}`,ContentType:"application/json",Body:$,...this.config.useChecksum&&{ChecksumSHA256:await $0($)}};const W=await this.s3ClientLite.putObject(z);return console.log(`${this.config.label} ${J.operation} ${z.Bucket}/${z.Key} => ${W.VersionId}`),W}async _deleteObject(J){const $={Bucket:J.ref.bucket,Key:J.ref.key},z=await this.s3ClientLite.deleteObject($);return console.log(`${this.config.label} ${J.operation||"DELETE"} ${J.ref.bucket}/${J.ref.key} => ${z.VersionId}`),z}subscribe(J,$,z){const W={...this.config.defaultManifest,...z?.manifest},Y={key:typeof J==="string"?J:J.key,bucket:J.bucket||this.config.defaultBucket||W.bucket},X=this.getOrCreateManifest(W),Z=X.subscribe(Y,$);return this.get(Y,{manifest:W}).then((Q)=>{console.log(`${this.config.label} NOTIFY (initial) ${P(Y)}`),queueMicrotask(()=>{$(Q,void 0),X.poll()})}).catch((Q)=>{$(void 0,Q)}),Z}refresh(){return Promise.all([...this.manifests.values()].map((J)=>J.poll()))}get subscriberCount(){return[...this.manifests.values()].reduce((J,$)=>J+$.subscriberCount,0)}}export{D0 as MPS3};
